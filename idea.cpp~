#include <GL/gl.h>
#include <SDL/SDL.h> //take that, glut
#include <cstdio>
#include <GL/glu.h>
#include <cmath>


const int WINDOW_HEIGHT = 768;
const int WINDOW_WIDTH = 1024;
//no evil windows.h dependency xD
void handleresize(int,int);
void programloop(SDL_Surface*);
class Mouse_class
{
	enum
	{
		IDLE = 0,
		SHOWPIECE = 1,
		COORD = 2,
		GOD = 3
	} state_num;
	int state;
	public:
	Mouse_class()
	{
		state = IDLE;
	}
	void handleEvent(SDL_Event event)
	{
		if(event.type == SDL_MOUSEBUTTONUP)
		{
			if(event.button.button == SDL_BUTTON_LEFT)
			{
				state -= 1;
			}
			if(event.button.button == SDL_BUTTON_RIGHT)
			{
				state -= 2;
			}
		}	
		if(event.type == SDL_MOUSEBUTTONDOWN)
		{
			if(event.button.button == SDL_BUTTON_LEFT)
			{
				state += 1;
			}
			if(event.button.button == SDL_BUTTON_RIGHT)
			{
				state += 2;	
				//if(state == coord) -> do right click stuff
			}
		}
		if(state == GOD && event.type == SDL_MOUSEMOTION)
		{
			glMatrixMode(GL_PROJECTION);
			glRotatef((GLfloat)event.motion.xrel, 0.0,1.0,0.0);
			glRotatef((GLfloat)event.motion.yrel, 0.0,0.0,1.0);						
		}	
	}
};
struct vert
{
	GLfloat height;
	GLfloat distance; //for the programs it maybe useful to have a distance or even a coordinate, 
};
class Surface_class
{
	GLint width;
	GLint length;
	GLfloat dist; //distance each of the vertacies are apart from each other
	vert *plane;
	public:
	Surface_class(GLint x, GLint y, GLfloat distance)
	{
		width = x;
		length = y;
		dist = distance;
		plane = new vert[width*length]; //allocate memory for the plane
	}
	~Surface_class()
	{
		delete[] plane;
	}
	void draw_surface() //renders new surface
	{
		//glMatrixMode(GL_MODELVIEW);
		glClear(GL_COLOR_BUFFER_BIT);
		glLoadIdentity();
		//glPushMatrix();			
		//glTranslatef(
		for(int x = 0; x < width-1; ++x)
		{
			glBegin(GL_TRIANGLE_STRIP);
			for(int y = 0; y < length; ++y)
			{
				glVertex3f((GLfloat)x*dist,accessVert(x,y).height,(GLfloat)y*dist);	
				glVertex3f((GLfloat)(x+1)*dist,accessVert(x,y).height,(GLfloat)y*dist);	
			}
			glEnd();	

		}	
		//glPopMatrix();
		glFlush();
		SDL_GL_SwapBuffers();
	}
	vert accessVert(int x, int y)
	{
		if(!(x > width || y > length))
		{
			return plane[x+y*width];
		}
		else
		{
			throw printf("acessVert out of bounds error!!!\n");
		}	
	}
	/*
		we need a funciton to draw the method, one to clear and refresh, our individual part is to determine the width
	*/
};
int main(int argc, char **argv)
{
	//declare SDL surface
	SDL_Surface *surface;
	//init window
	SDL_Init(SDL_INIT_EVERYTHING);
	surface = SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, 32, SDL_OPENGL|SDL_RESIZABLE);
	if(surface == NULL){ printf("SDL Init Error\n"); return 1;} //error check code
	SDL_WM_SetCaption(argv[0],NULL);
	programloop(surface);	
	/*
		to do:

		*handle resize -> later
		*handle mouse ->later
		*render surface -> sorta done
		*handle keybord	-> later 
		*remove test code ->done, for now
	*/
		
	//exit SDL
	SDL_Quit();
	return 0;	
}
void programloop(SDL_Surface *surf)
{
	
	int continueloop =1;
	SDL_Event event;
	Surface_class heightmap(90,90,0.4);
	Mouse_class mouse;	
	glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
	//glMatrixMode(GL_PROJECTION);
	//glRotatef(85.0,1.0,1.0,0.0);
	//gluLookAt(0.0,9.0,1.0,3.5,1.0,0.0,0.0,1.0,0.0);
	gluPerspective(90.0,(GLfloat)WINDOW_WIDTH/(GLfloat)WINDOW_HEIGHT,1.0,7000.0);
	
	while(continueloop) //maybe: input and GL on separate threads?
	{
		
		if(SDL_PollEvent(&event)) //if event has changed
		{
			switch(event.type)
			{
				case SDL_KEYDOWN:
					switch(event.key.keysym.sym) //press keys
					{
						case SDLK_ESCAPE: 
							continueloop = 0;
						break;
						case SDLK_UP:
						glMatrixMode(GL_MODELVIEW);
						glTranslatef(1.0,0.0,0.0);
					case SDLK_DOWN:
						glMatrixMode(GL_MODELVIEW);
						glTranslatef(-1.0,0.0,0.0);
					}
				break;
				case SDL_QUIT:
					printf("Booobies!!!!!!\n");
					continueloop = 0;
				break;
				case SDL_VIDEORESIZE:
					handleresize(event.resize.w,event.resize.h);
				break;
				case SDL_MOUSEMOTION:case SDL_MOUSEBUTTONUP: case SDL_MOUSEBUTTONDOWN:
					mouse.handleEvent(event);
				break;	
			}
		}
		else
		{
			if(event.type == SDL_KEYDOWN) //hold down keys
			{
				switch(event.key.keysym.sym)
				{
					case SDLK_UP:
						//glMatrixMode(GL_MODELVIEW);
						glTranslatef(1.0,0.0,0.0);
					break;
					case SDLK_DOWN:
						//glMatrixMode(GL_MODELVIEW);
						glTranslatef(-1.0,0.0,0.0);
					break;
				}
			
			}
		}	
		heightmap.draw_surface();
	}

}
void handleresize(int x, int y)
{ //a little buggy
/*	glViewport(0,0,x,y);	
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.0,1.0,-1.0,1.0,-1.0,1.0);
	glMatrixMode(GL_MODELVIEW);*/	
}
/*
struct vec
{
	float x,y,z;
};
class Veiwer
{
	float phi, psi;
	vec position;
	vec veiw;
	vec ortho; //orthgonal vector for view call	
	public:
	Veiwer()
	{
		rotate(phi,psi);
	}
	void movefoward(float units)
	{
		position.x += veiw.x*units;
		position.y += veiw.y*units;
		position.z += veiw.z*units;
	}
	void rotate(float a, float b)
	{
		phi = fmod(phi+a,360.0);
		psi = fmod(psi+b,360.0);
		veiw.x = cos(phi)*cos(psi);
		veiw.y = sin(psi);
		veiw.z = sin(phi)*cos(psi); 
		ortho.x = -cos(phi)*sin(psi);
		ortho.y = cos(psi);
		ortho.z = -sin(phi)*sin(psi);
	}
	void look()
	{
		gluLookAt(position.x,position.y,position.z,position.x + veiw.x, position.y + veiw.y, position.z + veiw.z, ortho.x,ortho.y,ortho.z);
	}
};
*/